[![Foo](https://img.shields.io/badge/Version-2.11-brightgreen.svg?style=flat-square)](#versions)
[![Foo](https://img.shields.io/badge/Website-AlexGyver.ru-blue.svg?style=flat-square)](https://alexgyver.ru/)
[![Foo](https://img.shields.io/badge/%E2%82%BD$%E2%82%AC%20%D0%9D%D0%B0%20%D0%BF%D0%B8%D0%B2%D0%BE-%D1%81%20%D1%80%D1%8B%D0%B1%D0%BA%D0%BE%D0%B9-orange.svg?style=flat-square)](https://alexgyver.ru/support_alex/)

[![Foo](https://img.shields.io/badge/README-ENGLISH-brightgreen.svg?style=for-the-badge)](https://github-com.translate.goog/GyverLibs/FastBot?_x_tr_sl=ru&_x_tr_tl=en)

# FastBot
Очень простая и быстрая библиотека для телеграм бота на esp8266/esp32
- Работает на стандартных библиотеках
- Работает без SSL
- Оптимизирована для большой нагрузки
- Опциональный белый список ID чатов
- Проверка обновлений вручную или по таймеру
- Отправка/удаление/редактирование/ответ на сообщения
- Отправка стикеров
- Вывод меню и инлайн меню (с поддержкой ссылок)
- Изменение названия и описания чата
- Закрепление/открепление сообщений
- Поддержка Unicode (другие языки + эмодзи) для входящих сообщений
- Встроенный urlencode для исходящих сообщений
- Встроенные часы реального времени с синхронизацией от сервера Telegram

### Совместимость
ESP8266 (SDK v2.6+), ESP32

## Документация и проекты
Подробные уроки по работе с Телеграм ботом при помощи этой библиотеки можно найти на [сайте Arduino набора GyverKIT](https://kit.alexgyver.ru/tutorials-category/telegram/)

## Сравнение с Universal-Arduino-Telegram-Bot
[Universal-Arduino-Telegram-Bot](https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot)  

Для сравнения использовался минимальный пример с отправкой сообщения в чат и выводом входящих сообщений в сериал:
- **send** - отправка сообщения в чат
- **update** - проверка входящих сообщений
- **free heap** - объём свободной оперативной памяти во время работы программы

| Library   | Flash, B | SRAM, B | send, ms | update, ms | free heap, B |
|-----------|----------|---------|----------|------------|--------------|
| Univ..Bot | 400004   | 29848   | 2000     | 1900       | 38592        |
| FastBot   | 393220   | 28036   | 70       | 70         | 37552        |
| diff      | 6784     | 1812    | 1930     | 1830       | 1040         |

- FastBot легче почти на 7 кБ Flash и 2 кБ SRAM, но занимает на 1 кБ в SRAM больше во время работы программы. Итого легче на 2-1 = 1 кБ SRAM.
- FastBot значительно быстрее обрабатывает чат и отправляет сообщения (на 2 секунды) за счёт ручного парсинга ответа сервера и статически выделенных HTTP клиентов

## Содержание
- [Установка](#install)
- [Инициализация](#init)
- [Документация](#docs)
- [Использование](#usage)
- [Пример](#example)
- [Версии](#versions)
- [Баги и обратная связь](#feedback)

<a id="install"></a>
## Установка
- Библиотеку можно найти по названию **FastBot** и установить через менеджер библиотек в:
    - Arduino IDE
    - Arduino IDE v2
    - PlatformIO
- [Скачать библиотеку](https://github.com/GyverLibs/FastBot/archive/refs/heads/main.zip) .zip архивом для ручной установки:
    - Распаковать и положить в *C:\Program Files (x86)\Arduino\libraries* (Windows x64)
    - Распаковать и положить в *C:\Program Files\Arduino\libraries* (Windows x32)
    - Распаковать и положить в *Документы/Arduino/libraries/*
    - (Arduino IDE) автоматическая установка из .zip: *Скетч/Подключить библиотеку/Добавить .ZIP библиотеку…* и указать скачанный архив
- Читай более подробную инструкцию по установке библиотек [здесь](https://alexgyver.ru/arduino-first/#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA)

<a id="init"></a>
## Инициализация
```cpp
FastBot bot;
FastBot bot(токен);
FastBot bot(токен, лимит);
FastBot bot(токен, лимит, порог);
FastBot bot(токен, лимит, порог, период);
// токен - уникальный код бота, берётся у BotFather
// лимит - количество сообщений, получаемое из одного запроса (по умолч. 10)
// порог - количество символов, при котором API запрос будет считаться слишком большим и будет пропущен (по умолч. 10000)
// период - период автоматического опроса бота в мс (по умолч. 3500)
```

<a id="docs"></a>
## Документация
```cpp
// ============== НАСТРОЙКИ ==============
void setToken(String token);                    // изменить/задать токен бота
void setChatID(String chatID);                  // установка ID чата (белый список), необязательно. Можно несколько через запятую ("id1,id2,id3")
void setPeriod(int period);                     // период опроса в мс (по умолч. 3500)
void setLimit(int limit);                       // макс кол-во сообщений на запрос
void setOvf(int ovf);                           // макс кол-во символов на запрос (защита от флуда)
void setBufferSizes(uint16_t rx, uint16_t tx);  // установить размеры буфера на приём и отправку, по умолч. 512 и 512 байт (только для esp8266)

void setTextMode(uint8_t mode);                 // режим текста "для отправки": FB_TEXT, FB_MARKDOWN, FB_HTML (см. пример textMode)
void notify(bool mode);                         // true/false вкл/выкл уведомления от сообщений бота (по умолч. вкл)
void clearServiceMessages(bool state);          // удалять из чата сервисные сообщения о смене названия и закреплении сообщений (умолч. false)


// =============== ПАРСИНГ ===============
void attach(callback);                          // подключение функции-обработчика сообщений
void detach();                                  // отключение обработчика сообщений


// ================ ТИКЕР ================
uint8_t tick();                                 // проверка обновлений по таймеру
uint8_t tickManual();                           // ручная проверка обновлений


// ============== СООБЩЕНИЯ ==============
// отправить сообщение в указанный в setChatID чат/чаты ИЛИ передать id чата
uint8_t sendMessage(String msg);
uint8_t sendMessage(String msg, String id);

// редактировать сообщение (msgid) в указанном в setChatID чате ИЛИ передать id чата
uint8_t editMessage(int32_t msgid, String text);
uint8_t editMessage(int32_t msgid, String text, String id);

// ответить на сообщение с id (replyID) в указанный в setChatID чат ИЛИ указать чат
uint8_t replyMessage(String msg, int32_t replyID);
uint8_t replyMessage(String msg, int32_t replyID, String id);

// отправить стикер в указанный в setChatID чат/чаты ИЛИ передать id чата
uint8_t sendSticker(String stickerID);
uint8_t sendSticker(String stickerID, String id);

// ответить на callback текстом (text) и режимом (alert): FB_NOTIF - уведомление в чате, FB_ALERT - окно с кнопкой ОК
uint8_t answer(String text, bool alert);


// =============== УДАЛЕНИЕ ===============
// удалить сообщение с id (msgid) в указанном в setChatID чате ИЛИ передать id чата
// удаляет любые типы сообщений (текст, стикер, инлайн меню)
uint8_t deleteMessage(int32_t msgid);
uint8_t deleteMessage(int32_t msgid, String id);


// ============= ОБЫЧНОЕ МЕНЮ =============
// показать меню (menu) в указанном в setChatID чате/чатах ИЛИ передать id чата/чатов 
uint8_t showMenu(String menu);
uint8_t showMenu(String menu, String id);

// единоразовое меню (закроется при выборе) в текущем чате ИЛИ передать id чата
uint8_t showMenu(String menu, true);
uint8_t showMenu(String menu, String id, true);

// скрыть меню в указанном в setChatID чате/чатах ИЛИ передать id чата/чатов 
uint8_t closeMenu();
uint8_t closeMenu(String id);


// ======== ОБЫЧНОЕ МЕНЮ С ТЕКСТОМ =========
// сообщение (msg) + показать меню (menu) в указанном в setChatID чате/чатах ИЛИ передать id чата/чатов 
uint8_t showMenuText(String msg, String menu);
uint8_t showMenuText(String msg, String menu, String id);

// единоразовое меню (закроется при выборе)
uint8_t showMenuText(String msg, String menu, true);
uint8_t showMenuText(String msg, String menu, String id, true);

// сообщение (msg) + скрыть меню в указанном в setChatID чате/чатах ИЛИ передать id чата/чатов 
uint8_t closeMenuText(String msg);
uint8_t closeMenuText(String msg, String id);


// ============= ИНЛАЙН МЕНЮ =============
// сообщение (msg) с инлайн меню (menu) в указанном в setChatID чате/чатах ИЛИ передать id чата/чатов
uint8_t inlineMenu(String msg, String menu);
uint8_t inlineMenu(String msg, String menu, String id);

// редактировать меню (msgid) текстом (menu) в указанном в setChatID чате ИЛИ передать id чата
uint8_t editMenu(int32_t msgid, String menu);
uint8_t editMenu(int32_t msgid, String menu, String id);


// ======= ИНЛАЙН МЕНЮ С КОЛЛБЭКОМ =======
// сообщение (msg) с инлайн меню (menu) и коллбэком (cbck) в указанном в setChatID чате/чатах ИЛИ передать id чата/чатов
uint8_t inlineMenuCallback(String msg, String menu, String cbck);
uint8_t inlineMenuCallback(String msg, String menu, String cbck, String id);

// редактировать меню (msgid) текстом (menu) и коллбэком (cback) в указанном в setChatID чате ИЛИ передать id чата
uint8_t editMenuCallback(int32_t msgid, String menu, String cback);
uint8_t editMenuCallback(int32_t msgid, String menu, String cback, String id);


// ============== ГРУППОВЫЕ ==============
// для всех групповых команд бот должен быть админом в чате!

// установить имя группы в указанном в setChatID чате ИЛИ передать id чата
uint8_t setChatTitle(String& title);
uint8_t setChatTitle(String& title, String& id);

// установить описание группы в указанном в setChatID чате ИЛИ передать id чата
uint8_t setChatDescription(String& description);
uint8_t setChatDescription(String& description, String& id);

// закрепить сообщение с ID msgid в указанном в setChatID чате ИЛИ передать id чата
uint8_t pinMessage(int32_t msgid);
uint8_t pinMessage(int32_t msgid, String& id);

// открепить сообщение с ID msgid в указанном в setChatID чате ИЛИ передать id чата
uint8_t unpinMessage(int32_t msgid);
uint8_t unpinMessage(int32_t msgid, String& id);

// открепить все сообщения в указанном в setChatID чате ИЛИ передать id чата
uint8_t unpinAll();
uint8_t unpinAll(String& id);


// ============= КОМАНДА API =============
// отправить команду API в указанном в setChatID чате ИЛИ передать id чата (id сам добавится в команду)
// (пример команды: "/sendSticker?sticker=123456")
uint8_t sendCommand(String& cmd);
uint8_t sendCommand(String& cmd, String& id);


// ================ СЕРВИС ===============
int32_t lastBotMsg();                           // ID последнего отправленного ботом сообщения
int32_t lastUsrMsg();                           // ID последнего отправленного юзером сообщения
String chatIDs;                                 // указанная в setChatID строка, для отладки и редактирования списка

uint8_t sendRequest(String& req);               // отправить запрос (https://api.telegram.org/bot...)
void autoIncrement(boolean incr);               // авто инкремент сообщений (по умолч включен)
void incrementID(uint8_t val);                  // вручную инкрементировать ID на val


// ================ ВРЕМЯ =================
FB_Time getTime(int16_t gmt);       // получить текущее время, указать часовой пояс (например Москва 3) в часах или минутах
bool timeSynced();                  // проверка, синхронизировано ли время
uint32_t getUnix();                 // получить текущее unix время

// структура FB_Time
uint8_t second;         // секунды
uint8_t minute;         // минуты
uint8_t hour;           // часы
uint8_t day;            // день месяца
uint8_t month;          // месяц
uint8_t dayWeek;        // день недели (пн..вс 1..7)
uint16_t year;          // год
String timeString();    // получить строку времени формата ЧЧ:ММ:СС
String dateString();    // получить строку даты формата ДД.ММ.ГГГГ


// =============== СТАТУС ================
// Многие функции возвращают статус:
// 0 - ожидание
// 1 - ОК
// 2 - Переполнен по ovf
// 3 - Ошибка телеграм
// 4 - Ошибка подключения
// 5 - не задан chat ID
// 6 - множественная отправка, статус неизвестен
// 7 - не подключен обработчик


// ========== ДЕФАЙНЫ НАСТРОЕК ==========
// объявлять ПЕРЕД подключением библиотеки
#define FB_NO_UNICODE   // отключить конвертацию Unicode для входящих сообщений (чуть ускорит программу)
#define FB_NO_URLENCODE // отключить конвертацию urlencode для исходящих сообщений (чуть ускорит программу)
```

<a id="usage"></a>
## Использование
### ID чата/чатов
В библиотеке реализован необязательный "белый список" ID чатов, в которых работает бот. По умолчанию отключен.
- Устанавливается через `setChatID()`, куда можно передать одиночный ID или сразу несколько через запятую: `setChatID("id1,id2,id3")`
- Можно редактировать строку `chatIDs` напрямую как член класса
- Все функции отправки будут отправлять данные в заданный чат/чаты, если не указать его вручную в функции

### Парсинг сообщений
Сообщения автоматически читаются в `tick()`, при поступлении нового сообщения вызывается указанная функция-обработчик. Но тут есть варианты:
- Если задан ID чата/чатов (через `setChatID()`) - происходит автоматическое отсеивание сообщений НЕ из указанных чатов
- Если ID чата/чатов не задан (через `setChatID()`) - сообщение будет обработано, т.е. вызван обработчик

Обработчик подключается при помощи `attach(FB_msg&)`
- Создаём в скетче свою функцию вида `void функция(FB_msg& сообщение)`
- Вызываем `attach(функция)`
- Эта функция будет автоматически вызвана при входящем сообщении, если ID чата совпадают или не настроены
- Если обработчик не подключен - сообщения не будут опрашиваться!
- Внутри этой функции можно пользоваться переданной переменной `сообщение`, которая имеет тип `FB_msg` (структура) и содержит в себе:
    - `String userID` - ID пользователя
    - `String username` - имя пользователя (в API Telegram это first_name)
    - `String chatID` - ID чата
    - `int32_t messageID` - ID сообщения в чате
    - `String text` - текст сообщения
    - `String data` - callback дата сообщения (если есть)
    - `bool query` - запрос
    - `bool edited` - сообщение отредактировано
    - `bool isBot` - сообщение от бота
    - `uint32_t unix` - время сообщения
    
С версии 2.11 добавлен метод `toString()`, позволяющий вывести строкой всё содержимое структуры
```cpp
  Serial.println(msg.toString())
```

### Тикер
Для опроса входящих сообщений нужно подключить обработчик сообщений и вызывать `tick()` в главном цикле программы `loop()`, опрос происходит по встроенному таймеру. 
По умолчанию период опроса установлен 3600 миллисекунд. Можно опрашивать чаще (сменить через `setPeriod()`), но Телеграм иногда тупит и 
при частом опросе запрос может выполняться ~3 секунды вместо 60 миллисекунд! На это время программа "зависает" внутри `tick()`. 
При периоде ~3600 мс этого не происходит, поэтому я сделал его по умолчанию.

### Минимальный пример
```cpp
void setup() {
  // подключаемся к WiFi
  bot.attach(newMsg);   // подключаем обработчик сообщений
}

void newMsg(FB_msg& msg) {
  // выводим имя юзера и текст сообщения
  //Serial.print(msg.username);
  //Serial.print(", ");
  //Serial.println(msg.text);
  
  // выводим всю информацию о сообщении
  Serial.println(msg.toString());
}

void loop() {
  bot.tick();
}
```

### Обращение к сообщениям
Для редактирования и удаления сообщений и меню, а также закрепления сообщений, нужно знать ID сообщения.
- ID входящего сообщения приходит в обработчик входящих сообщений
- ID последнего принятого сообщения можно получить из `lastUsrMsg()`
- ID последнего отправленного ботом сообщения можно получить из `lastBotMsg()`

Будьте внимательны с ID чата, у всех чатов своя нумерация ID сообщений!

### Отправка стикеров
Для отправки стикера нужно знать ID стикера. Отправь нужный стикер боту *@idstickerbot*, он пришлёт ID стикера. 
Этот ID нужно передать в функцию `sendSticker()`.

### Меню
> Примечание: для всех вариантов меню *не производится* url encode. Избегайте символов `#` и `&` или используйте уже закодированный url!

Для отправки меню используется строка с именами кнопок и специальным форматированием:
- `\t` - горизонтальное разделение кнопок
- `\n` - вертикальное разделение кнопок
- Лишние пробелы вырезаются автоматически

Пример меню 3x1: `"Menu1 \t Menu2 \t Menu3 \n Menu4"`

Результат:
```cpp
 _______________________
|       |       |       |
| Menu1 | Menu2 | Menu3 |
|_______|_______|_______|
|                       |
|       M e n u 4       |
|_______________________|
```

### Обычное меню
Большое меню в нижней части чата.
```cpp
showMenu("Menu1 \t Menu2 \t Menu3 \n Menu4");
```
Нажатие на кнопку отправляет текст с кнопки (поле сообщения `text`).

### Инлайн меню
Меню в сообщении. Требует ввода имени меню.
```cpp
inlineMenu("MyMenu", "Menu1 \t Menu2 \t Menu3 \n Menu4");
```
Нажатие на кнопку отправляет имя меню (поле сообщения `text`) и текст с кнопки (поле сообщения `data`).

### Инлайн меню с коллбэком
Меню в сообщении. Позволяет задать каждой кнопке уникальный текст, который будет отправляться ботом вместе с именем меню. 
Список коллбэков перечисляется через запятую по порядку кнопок меню:
```cpp
String menu1 = F("Menu 1 \t Menu 2 \t Menu 3 \n Back");
String cback1 = F("action1,action2,action3,back");
bot.inlineMenuCallback("Menu 1", menu1, cback1);
```
Нажатие на кнопку отправляет имя меню (поле сообщения `text`) и указанные данные (поле сообщения `data`).
- (С версии 2.11) если callback задан как http/https адрес, кнопка автоматически станет **кнопкой-ссылкой**

### Ответ на коллбэк
При нажатии на кнопку инлайн-меню боту отправляется коллбэк, в обработчике сообщения будет поднят флаг `query`. Сервер Телеграм будет ждать ответа. 
Ответить на коллбэк можно при помощи:
- `answer(текст, FB_NOTIF)` - всплывающий текст-уведомление
- `answer(текст, FB_ALERT)` - окно с предупреждением и кнопкой ОК

Отвечать нужно **внутри обработчика сообщения**! Пример:
```cpp
void newMsg(FB_msg& msg) {
  if (msg.query) bot.answer("Hello!", true);
}
```

> Если ничего не отвечать, библиотека сама отправит пустой ответ и "таймер" на кнопке исчезнет.

### Модуль времени
В библиотеке есть тип данных `FB_Time`, который является структурой с полями:
```cpp
uint8_t second;     // секунды
uint8_t minute;     // минуты
uint8_t hour;       // часы
uint8_t day;        // день месяца
uint8_t month;      // месяц
uint8_t dayWeek;    // день недели (пн..вс 1..7)
uint16_t year;      // год
```

При создании структуры можно указать unix время и часовой пояс в часах или минутах (например 3 часа ИЛИ 180 минут для Москвы (UTC+3:00), 
330 минут для Индии (UTC+5:30)). После этого можно забирать нужные значения времени:

```cpp
FB_Time t(1651694501, 3);
Serial.print(t.hour);
Serial.print(':');
Serial.print(t.minute);
Serial.print(':');
Serial.print(t.second);
Serial.print(' ');
Serial.print(t.day);
Serial.print(':');
Serial.print(t.month);
Serial.print(':');
Serial.println(t.year);
```

С версии 2.9 библиотека умеет выводить форматированное время (String):
```cpp
Serial.print(t.timeString());   // ЧЧ:ММ:СС
Serial.print(' ');
Serial.println(t.dateString()); // ДД.ММ.ГГГГ
```

### Время получения сообщения
В обработчике входящих сообщений у структуры `FB_msg` есть поле `unix`, оно хранит время сообщения в unix формате. 
Для перевода в более читаемый формат действуем по описанной выше схеме:
```cpp
void newMsg(FB_msg& msg) {
  FB_Time t(msg.unix, 3);   // передали unix и часовой пояс
  Serial.print(t.timeString());
  Serial.print(' ');
  Serial.println(t.dateString());
}
```

### Часы реального времени
В ответ на любое сообщение от бота сервер сообщает время отправки в формате unix. С версии 2.6 это время парсится 
библиотекой и **счёт продолжается дальше** при помощи стандартных функций времени. Таким образом достаточно один раз отправить 
сообщение после включения платы, чтобы библиотека синхронизировала часы. При дальнейших отправках время также будет синхронизироваться 
и уточняться, т.к. вычисляемое средствами esp время будет уходить (~2 секунды в сутки). Инструменты:

- `uint32_t getUnix()` - вернёт текущее время в unix формате или `0`, если время не синхронизировано.
- `bool timeSynced()` - вернёт `true` если часы синхронизированы. 
- `FB_Time getTime(gmt)` - нужно передать свой часовой пояс, она вернёт `FB_Time`.

Таким образом получить время можно двумя способами (см. пример timeTest):
```cpp
FB_Time t = bot.getTime(3);
// или
FB_Time t(bot.getUnix(), 3);
```

<a id="example"></a>

<a id="versions"></a>
## Версии
- v1.0
- v1.1 - оптимизация
- v1.2 - можно задать несколько chatID и отправлять в указанный чат
- v1.3 - добавлена возможность задать текст при открытии и закрытии меню
- v1.3.1 - исправлены ошибки с 1.3
- v1.4 - добавлена возможность удалять сообщения
- v1.5 - оптимизация, возможность смены токена, новый парсинг сообщений (id, имя, текст)
- v1.5.1 - получаем также ID сообщения
- v1.6 - добавлен режим FB_DYNAMIC_HTTP, чтение имени пользователя
- v1.7:
  - Убрал динамический режим FB_DYNAMIC_HTTP, работает слишком медленно
  - Исправил warningи
  - Починил работу бота в "группах" (отрицательный ID чата)
  - Оптимизация памяти
  - Ускорил работу
  - Пофиксил работу через раз в сценарии "эхо"
  
- v2.0:
    - Убрал минимум в 3200 мс
    - Добавил обработку Юникода (русский язык, эмодзи). Спасибо Глебу Жукову!
    - Из меню удаляются лишние пробелы, работать стало проще
    - Поддержка esp32
    - Большая оптимизация
    - Добавил коллбэки в inlineMenu
    - Добавил ID юзера
    - Добавил редактирование сообщений и кучу всего

- v2.1: 
    - Ещё оптимизация
    - Добавил форматирование текста (markdown, html)
    - Добавил ответ на сообщение

- v2.2:
    - Большая оптимизация памяти и производительности
    - Добавил notify() - уведомления от сообщений бота
    - Добавил единоразовый показ клавиатуры
    
- v2.3: Небольшая оптимизация
- v2.4: Добавил url encode для текста сообщений
- v2.5: Добавил флаги в FB_msg: сообщение отредактировано и сообщение отправлено ботом. Улучшил парсинг текста
- v2.6: Добавил встроенные часы реального времени
- v2.7: Добавил отправку стикеров
- v2.8: Убрал лишний вывод в сериал, GMT можно в минутах
- v2.9: Исправлена бага в парсинге, парсинг ускорен, добавлен вывод форматированного времени, добавлена фамилия и время сообщения
- v2.10: Добавлены функции для изменения названия и описания чата, закрепления и открепления сообщений. Убраны edit/deleteMessageID, editMenuID
- v2.11: 
    - Оптимизация, исправление багов
    - Callback data теперь парсится отдельно в data
    - Переделана работа с callback
    - Добавлен toString() для FB_msg для отладки
    - В callback добавлена обработка url адресов
    - Убраны first_name и last_name (с сохранением легаси)
    - usrID и ID переименованы в userID и messageID (с сохранением легаси)
    - Окончательно убран старый обработчик входящих сообщений
    
<a id="feedback"></a>
## Баги и обратная связь
При нахождении багов создавайте **Issue**, а лучше сразу пишите на почту [alex@alexgyver.ru](mailto:alex@alexgyver.ru)  
Библиотека открыта для доработки и ваших **Pull Request**'ов!
